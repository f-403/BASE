---
layout: post
tags: [masm]
---

```bash
地址总线 //寻址能力
数据总线 //一次传送数据大小
控制总线 //对其他元件的控制能力

```



**1.通用寄存器:**



```bash
ax, bx, cx, dx
```



字节由高8位与低8位组成， 如:

```bash
ax => ah+al
ah => HH
al => 11
ax = HH+11
```



**2.指令执行地址:**

修改`CS, IP:`

`cs`段地址

`ip`偏移地址

```bash
MOV AX, 1000
MOV CS, AX
MOV IP, AX
//CS, IP不能直接修改， 要借用通用寄存器来修改	
//如果要同时修改cs,ip, 可以用如下方式：
jmp 2ae3:3 //执行后CPU从这个地址执行指令:2ae3x16+3 => 2ae33
//如果你 `jmp 某一合法寄存器` 的形式， 默认是修改IP的内容
jmp ax //修改ip的值为ax的值
jmp 123 //修改ip的值为0123

```

> `cs:ip`为程序入口: `csx16+ip`



**3.数据储存地址**

`DS`为数据地址

数据实际地址为: `dsx16+编移地址 = 数据真实地址`

`ds`也不能直接`mov`, 可以借助` ax，bx, cx`等 :

```
mov ax, 1000
mov ds, ax //ax数据传到ds地址
mov bx,[1] //把相对于ds偏移地址为1的地址传入bx
mov ds,[1] //把相对于ds偏移地址为1的地址传入ds
//注意这个ds不能: mov ds,0001
```

可以先用`d`查看内存数据再执行看效果。

`如: d 30e0:0`

> 注意: 从内存地址中读数据出来(`[address]`), 一次读取一个字， 也就是一次读两字节，如`ABCD`。读`[address]`, 会取`address+(address+1)`。

```
3e20:0000 01 02 03 04 ....
3e20:0010 0a 0b 0c 0d ....
...
//比如ds为3e20, 偏移地址从0开始的话
//[0] => 0000
//[1] => 0100
//[2] => 0201
...
//右边是高位，先取， 再两个合并
//注意比如这里的[2] => 0201, 其中02是高位， 01是低位
//02为一字节， 十六位， 0 => 高8位(如ah), 2 => 低8位(如al)
```



**4.栈**

`SS`与`SP`

`SS`:栈顶

`SP`:偏移地址

`push`入栈

`pop`出栈

栈的进出都是以字为单元， 也就是说每操作一次会操作两字节(一个字), 一个16进制(如ABCD)。

一个`push`例子:

```
100bh  #====#
100ch  #====#	
100dh  #====#
100eh  #=23=# <--ss:sp
100fh  #=01=#
-------+----+-----------------
10010  ###### <--当元素为空时指向这里， 假设上面的100fh是栈底最后的元素
ss:1000h,sp:000eh => 1000x16+000e = 100eh
mov ax,0123h
push ax
```

> 注意， 任何时候`ss:sp`指向栈顶。当栈没有元素时， `ss:sp`指向的是栈底部元素下面的元素。 如上图。



**总结: `CS`,`IP`,`DS`,`SS`,`SP`:**

```
cs,ds, ss 都不能add,sub, 只能进行mov, push,pop操作
ip不能mov,不能push,不能pop, 修改ip请使用jmp ax, jmp 1234等操作
jmp cs:ip 能同时修改cs跟ip
sp 可以mov,sub,add,push,pop
//不用记， 不知道的话用dosbox写一下就知道了

```

