##### 用new创建对象
```c++
#include <iostream>
#include <stdlib.h>

int main()
{
    //new Type, 返回相应类型的空间地址的指针
    //int *p = new;不确定值
    //int *p = new();0值
    //int *p = new(123);赋值为123
    int* test = NULL;
    test = new int;
    std::cout << test << std::endl;
    *test = 1234;
    std::cout << *test << std::endl;
    delete test;//删除空间

    //new创建数组
    //new Type[]
    //delete[] 变量名
    int* parr = new int[5];//值 没有初始化， 下面两条是带初始化值 的形式
    //int* parr = new int[5] {1,2,3,4,5};
    //int* parr = new int[5] {};
    for (int i = 0; i < 5; i++) {
        std::cout << parr[i] << std::endl;
    }


    std::cout << std::hex << parr << std::endl;//打印指针十六进制
    std::cout << std::hex << reinterpret_cast<unsigned long>(parr)<< std::endl;//把指针数值转换成unsigned long类型
    delete[] parr;// 删除申请的空间

    //还可以用malloc函数分配内存空间->头文件stdlib.h
    void* x = malloc(sizeof(int));
    std::cout << typeid(x).name() << std::endl;
    int* px = (int*)x;
    std::cout << typeid(px).name() << std::endl;
    free(x);
    
}
```

##### 复制构造与默认构造
```c++
#include <iostream>

class Test {
public:
    Test();
    Test(int a);
    Test(const Test& object);//内部会自带一个: Test(const Test &){}, 自带的实现方式为空 
};

Test::Test() { std::cout << "默认构造函数调用." << std::endl; }
Test::Test(int a){ std::cout << "自定义构造函数调用." << std::endl; }
Test::Test(const Test& object) { std::cout << "复制构造函数调用" << std::endl; };


int main()
{
    Test at;
    Test a(1);
    at = a;
    Test c = a;//当对象发生复制到新变量中时， 会调用复制构造函数
    Test cc = Test(); //这里没有发现调用复制构告函数
}

```

##### 初始化默认构造器(在一个类的对象创建时，初始化另一个类)
```c++
#include <iostream>

class A {

        class B {
            public:
                B() { std::cout <<"B中默认构造函数启用。" << std::endl; }
                B(std::string name) { std::cout<< "B类中自定义构造函数启用。" << std::endl; }
        };
    public:
        B b;
        A(int a) {}
        A(int a, std::string name) :b(name) {}
};
class Test {
    int a, b;
public:
    Test(int a, int b): b(b), a(a){}//初始化构造器
    void print_test() {
        std::cout << "a = " << this->a << ", b = " << this->b << std::endl;
    }

};

int main()
{
    A a = 1;//相当于A a(1)， 这样调用时， 因为每个调用对像都要初始化， 所以当创建A对像时， 对象包含有b对像的， 而b对像要初始化
    //所以你要写一个默认构造， 要不你要改写a对象构造时，怎么来初如化b对象
    A b(1, "name");
    Test test(1, 2);
    test.print_test();   
}
```

##### 类变量static
```c++
#include <iostream>

class A {
public:
    static int version;
    static void print_();
    static void print2_() {}
};

int A::version = 123; //类内定义， 初始化要放要类外， 用这样的形式, 也就是实体化要在函数外或类外， 类里面只是像函数那样， 当体定义，没有实化。
void A::print_() {} //类内定义， 类外实化。类函数不像类变量， 它能在类内部实体化
int main()
{
    A a;
    std::cout << A::version << std::endl;
    std::cout << a.version << std::endl;
    A::print_();
    a.print_();
    A::print2_();
    a.print2_();
}
```

##### const对象与const函数
```c++
#include <iostream>

class A {
public:

	void testa() const {}
	void testb() {}
};
int main()
{
	A a;
	a.testa();
	a.testb(); //普通创建的对像， const函数与普通函数都能访问

	const A b;
	b.testa();
	//b.testa;//不能调用非const的函数
}
```

##### 友元类
```c++
#include <iostream>

class A {
    friend class B;//定义了一个友元类B， 也就是说B能访问A中所有东西了。
private:
    int a; //私有成员， 但是用友元类访问
public:
    A(int a) {
        this->a = a;
    }
};

class B {
public:
    void check(A& a) {
        std::cout << "类A中私有成员的值是:" << a.a << std::endl;//这是在类A的外部， 目前能直接访问他的私有成员了。
    }
};
int main()
{
    A a(100);
    B b;
    b.check(a);//利用友元访问A中的私有数据
}
```

##### 友元函数
```c++
#include <iostream>
class A;
//类B定义如下:
class B {
public:
    void visit(A a);
};
//友元函数能直接访问对象的私有成员
class A {
    friend void friend_print(A a);//定义了一友元函数， 能用于在类外部访问类里面的私有成员。全局函数当作友元
    friend void B::visit(A a);//定义了一个友元函数， 这个友元函数是局于类B的， 不是一个全局友元函数， 但能从外部防问A中的私有数据

private:
    int a = 100;
    int b = 200;
};

//注意， 这是一个全局的友元函数
void friend_print(A a) {
    std::cout << a.a << a.b << std::endl;//如果不定义成友元， 会提示不可访问， 因为现在是在类外部， 外部是不能访问private的
}
void B::visit(A a) { //注意， 要在这里实现， 上面实现的话， 会出错， 在类A中添加友元函数后， 在类A后面再实现。顺序不能搞错
    std::cout << "从类B访问A中的私有数据:"  <<a.a << std::endl;
}

int main()
{
    B b;
    A a;
    //std::cout << a.a << a.b << std::endl; 因为是私有， 不能直接访问
    friend_print(a);
    
    b.visit(a);
}
```

##### class创建对象的特别形式
```c++
#include <iostream>

class Test {
    int a;
public:
    Test(int in){
        this->a = in;
    }
    void print_test() {
        std::cout << "a = " << this->a << std::endl;
    }
};
int main()
{
    Test test = 123;//相当于Test test = Test(123);
    test.print_test();

}
```

##### 如果一个函数的参数为一个父类的引用， 可以传它的子类的引用进去
```cpp
#include <iostream>
#include <fstream>
#include <string>

using namespace std;
void print_test(istream &os);
int main() {

	//父类的函数引用参数，可以传子类实参过去， 如istream的子类是ifstream, 函数参数为ostream &os时，
	// os可以传ofstream作为参数
	const char* filename = "test.txt";
	ifstream getfile;
	getfile.open(filename);
	print_test(getfile);
}
void print_test(istream& os) {
	//传送了一个ofstream参数过来
	std::string swap_line;
	while (std::getline(os, swap_line)) {
		std::cout << swap_line << std::endl;
	}

}
```

##### 父类构造函数与析构函数对于子类的作用
```cpp
#include <iostream>

class A {
public:
    A() {
        std::cout << "这是父类的构造函数" << std::endl;
    }
    ~A() {
        std::cout << "这是父类的析构函数" << std::endl;
    }
};
class a :public A {
public:
    a() {
        std::cout << "这是aaaa的构造函数" << std::endl;

    }
    ~a() {
        std::cout << "这是父类aaa的析构函数" << std::endl;
    }
};

int main()
{
    a mya;//除了调用自身的构造与析构， 还用调用父类的构造与析构

}
```

##### 复制构造函数
```cpp 
#固定格式
/*
class 类名 {
public:
    // 复制构造函数
    类名(const 类名& 引用名) {
        // 复制逻辑
    }
};
*/
#include <iostream>

class Test {
public:
    Test(Test& t) {
        std::cout << "复制构造函数被调用了" << std::endl;
    }
    Test() {
    }
};
int main()
{
    Test t;
    Test a = t;
    Test *b = new Test();

}
/*
1. 显式复制初始化
2. 函数对象参数按值传递
3. 函数返回的值为对象
4. 容器插入元素，如vec.push_back(obj)
5. 用另一个对象初始化新对象
6. 异常处理中的对象复制
try {
    throw T();  // 抛出异常对象时可能复制
} catch (T e) {  // 捕获异常时复制
    // ...
}
*/
```

##### 虚函数与纯虚函数
```cpp
#include <iostream>
#include <map>

//父类中使用 virtual void func() = 0; 声明纯虚函数，子类必须实现
//只在父类中写virtual就行， 子类可写可不写， 但建议写上
class Test {

    virtual void test() {
    }
    virtual void test2() = 0;
};
class Dog :public Test {
    virtual void test() {
        //相当于重写
    }
    void test2() {
        //必须要重写实现
    }
};
int main()
{
    //当设置为虚函数时， 引用或指针会查找 所属类型 
    //如果所属是 Dog, 就用Dog的test(), 如果所属是Test就用Test的test()
    ////Test &a = new Dog()   Dog中的test（）， 因为引用的值是Dog类
    //Test &b = new Test()  父类中的test（）， 因为引用的值是Test类
 
    //当没有设置虚函数时， 引用或指针调用的相应函数会是父类中的test() 
    //Test &a = new Dog()   父类中的test（）， 因为a是父类引用
    //Test &b = new Test()  父类中的test（）， 因为b是父类引用

    //也就是设置为虚函数后， 会按实际类型调用相应虚函数， 与父类没有关系
    /*
}

/*
//其他例子：
class Parent {
public:
    // 虚函数声明
    virtual void print() {
        std::cout << "Parent::print()" << std::endl;
    }
    
    // 非虚函数（仅作对比）
    void nonVirtualPrint() {
        std::cout << "Parent::nonVirtualPrint()" << std::endl;
    }
};

class Child : public Parent {
public:
    // 重写父类的虚函数
    void print() override {  // 使用override显式标记重写（C++11起支持）
        std::cout << "Child::print()" << std::endl;
    }
    
    // 重写父类的非虚函数（不推荐这样做）
    void nonVirtualPrint() {
        std::cout << "Child::nonVirtualPrint()" << std::endl;
    }
};

int main() {
    // 创建子类对象
    Child child;
    
    // 1. 通过子类对象直接调用（与虚函数无关）
    child.print();  // 输出：Child::print()
    child.nonVirtualPrint();  // 输出：Child::nonVirtualPrint()
    
    // 2. 通过父类指针调用（关键：虚函数实现多态）
    Parent* parentPtr = &child;
    parentPtr->print();  // 输出：Child::print()（动态绑定）
    parentPtr->nonVirtualPrint();  // 输出：Parent::nonVirtualPrint()（静态绑定）
    
    // 3. 通过父类引用调用（同样实现多态）
    Parent& parentRef = child;
    parentRef.print();  // 输出：Child::print()（动态绑定）
    parentRef.nonVirtualPrint();  // 输出：Parent::nonVirtualPrint()（静态绑定）
    
    return 0;
}   
    */
```

##### 友元函数
```cpp
#include <iostream>

class MyClass {
private:
    int value;
public:
    MyClass(int val) : value(val) {}

    // 声明友元函数
    friend std::ostream& operator<<(std::ostream& os, MyClass& obj);
};

// 定义全局函数
std::ostream& operator<<(std::ostream& os,  MyClass& obj) {
    os << "MyClass(value=" << obj.value << ")"; // 可以访问私有成员
    return os;
    //(cout << a) << b , 这个运算符重载规定第一个参数是ostream, 返回也是ostream
}

int main() {
    MyClass obj(42);
    std::cout << obj << std::endl; // 输出: MyClass(value=42)
    return 0;
}
```

##### 类中的转换函数， 比如一个类stu, 你想要int a = stu, 相当于把stu转换为int类型
```cpp
#include <iostream>

class Test {
public:
    operator int() {
        std::cout << "我是类对象， 现在转化成了一个int类型" << std::endl;
        return '0';
    }
};

int main()
{
    Test t{};
    int a = t;
}
```

